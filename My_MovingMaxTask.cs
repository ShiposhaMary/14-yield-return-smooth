using System;
using System.Collections.Generic;
using System.Linq;
/*В классе MovingMaxTask реализуйте функцию максимума в скользящем окне. Для каждой точки найдите максимум всех предшествующих точек в окне указанного размера. Алгоритм должен работать эффективно, то есть тратить на обработку одной точки в среднем O(1) времени, вне зависимости от размера окна.

Эта задача не так проста как кажется, поэтому ниже описана идея простого и компактного алгоритма, до которого, тем не менее, не так просто догадаться самостоятельно. Впрочем, у задачи существуют разные решения. Допустимы любые решения с требуемой сложностью.
Идея алгоритма

Итак, давайте как и в прошлой задаче MovingAverageTask хранить элементы текущего окна.

Мы не хотим пересчитывать максимум заново на каждой точке — это даст сложность обработки O(WindowSize), что слишком медленно по условию. Поэтому используем вспомогательную структуру данных, которая поможет это делать быстрее.

Будем отдельно хранить список только тех значений окна, которые потенциально могут стать максимумом в будущем. Значение не может стать максимумом, если после него в окно попало хоть одно значение больше него. Поэтому перед добавлением очередного элемента в этот список (будем считать, что добавляем мы справа) нужно удалить справа все элементы, меньшие нового. Несложно понять, что этот список будет упорядоченным, а значит максимум всех чисел в текущем окне будет в этом списке самым левым.

Для хранения этого списка потенциальных максимумов пригодится структура данных Deque (LinkedList в языке C#), в которой эффективно добавлять и удалять элементы можно с обоих концов списка.
*/
namespace yield
{

    public static class My_MovingMaxTask
    {
        public static IEnumerable<DataPoint> MovingMax(this IEnumerable<DataPoint> data, int windowWidth)
        {
            var points = new LinkedList<double>();
            var pointsX = new Queue<double>();
            foreach (var point in data)
            {
                pointsX.Enqueue(point.X);
                if (pointsX.Count > windowWidth && points.First.Value <= pointsX.Dequeue())
                {
                    points.RemoveFirst();
                    points.RemoveFirst();
                }
                while (points.Count != 0 && points.Last.Value < point.OriginalY)
                {
                    points.RemoveLast();
                    points.RemoveLast();
                }
                points.AddLast(point.X);
                points.AddLast(point.OriginalY);
                point.MaxY = points.First.Next.Value;
                yield return point;
            }
        }
    }
}
